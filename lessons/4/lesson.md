# Lesson 4: Creating Roles and Permissions

In this lesson, we will create roles and permissions for our users.

## 1. Creating Migrations
We need to have supabase installed, global or locally.
```bash
pnpm install -g supabase

or

pnpm install supabase
```

To create a migration, run the following command:

```bash
supabase migration new create_roles_and_permissions
```

## 2. How to create roles and permissions in Supabase

We will be creating tables and policies to manage roles and permissions.

For simplicity, we will create two roles: `admin` and `user`.

- `admin`: can read and write to all tables.
- `user`: can only read from certain tables.

By default, all users will be assigned the `user` role.
Otherwise, we will manually assign the `admin` role to specific users.

We will be adding these tables on the public schema.

You might also see this [documentation](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac#create-a-table-to-track-user-roles-and-permissions).

```sql
create type public.app_role as enum ('admin');

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
```

```sql
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;
    claims := event->'claims';
    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;
    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);
    -- Return the modified or original event
    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true)
```

## 3. Managing Permissions

We will be creating a table to manage permissions for our users.

In the future, we will be using this to create RLS (role-level security) policies.

```sql
create type public.app_permission as enum ('editor.manage');


-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
```

## 4. Assigning Roles to Users

Once we have the roles and permissions tables, we can check for the user's role in our application.

Make sure to install the `jwt-decode` package:

```tsx
import { jwtDecode } from "jwt-decode";

const { subscription: authListener } = supabase.auth.onAuthStateChange(
  async (event, session) => {
    if (session) {
      const jwt = jwtDecode(session.access_token);
      const userRole = jwt.user_role;
    }
  }
);
```
  
## 5. Running Migrations
To run the migration, use the following command:

```bash
supabase db push
```